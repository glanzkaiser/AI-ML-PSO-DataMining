
function [OUTPUT]=FirstOrderALMMoSystem(input,status,goal)
%% ALMMo system for regression (goal=='Regression')
%% ALMMo system for binary classification (goal=='Classification')
%% During the learning stage
%% status=='OnlineLearning' &&  goal=='Regression'
% input.X are the inputs of the system
% input.Y are the targeted outputs of the system
% OUTPUT.TrainedSystem are the trained ALMMo-1 system
% OUTPUT.Estimation are the outputs generated by the ALMMo-1 system with the respective inputs in an online manner.
%% status=='OnlineLearning' &&  goal=='Classification'
% input.X are the inputs of the system
% input.Y are the corresponding labels of the inputs
% OUTPUT.TrainedSystem is the trained ALMMo-1 system
% OUTPUT.Estimation are the estimated label generated by the ALMMo-1 system with the respective inputs in an online manner.

%% During the  validation stage
%% status=='Validation' &&  goal=='Regression'
% input.X are the inputs of the system
% input.TrainedSystem is the pretrained ALMMo-1 system
% OUTPUT are the outputs generated by the ALMMo-1 system with the respective inputs
%% status=='Validation' &&  goal=='Classification'
% input.X are the inputs of the system
% input.TrainedSystem is the pretrained ALMMo-1 system
% OUTPUT are the estimated labels generated by the ALMMo-1 system with the respective inputs
%%
if strcmp(status,'OnlineLearning')==1
    omega=10; % This value for initialising the covariance matrix of the consequent part of the fuzzy rules; The value is changeable.
    forgettingfactor=0.1; % Forgetting factor used by Regression. Recommended value [0, 0.1]; The value is changeable.
    % The higher the value is, the faster the ALMMo-1 system remove stale rules; "0" means the ALMMo-1 system will not remove stale rules.
    densitythreshold=0.8; % The threshold for adding a new rule; The value is changeable; 
    % The higher the value is, the less new rules the system will have.
    data=input.X;
    dataout=input.Y;
    if strcmp(goal,'Regression')==1 
        [SystemParam,output]=Regression_learning(data,dataout,omega,densitythreshold,forgettingfactor);
        OUTPUT.TrainedSystem=SystemParam;
        OUTPUT.Estimation=output;
    end
    if strcmp(goal,'Classification')==1
        [SystemParam,output]=Classification_learning(data,dataout,omega,densitythreshold);
        OUTPUT.TrainedSystem=SystemParam;
        OUTPUT.Estimation=output;
    end 
end
if strcmp(status,'Validation')==1
    if strcmp(goal,'Regression')==1
        SystemParam=input.TrainedSystem;
        data=input.X;
        [output]=Regression_validation(SystemParam,data);
        OUTPUT=output;
    end
    if strcmp(goal,'Classification')==1
        SystemParam=input.TrainedSystem;
        data=input.X;
        [output]=Classification_validation(SystemParam,data);
        OUTPUT=output;
    end 
end
end
function [SystemParam,Estimation]=Regression_learning(data,dataout,omega,densitythreshold,forgettingfactor)
[L,W]=size(data);
center=data(1,:);  % the centre of the first data cloud
Global_mean=data(1,:); % global mean
Global_X=sum(data(1,:).^2);% global average scalar product
Local_X=sum(data(1,:).^2); % the average scalar product of the first data cloud
Support=1; % the support of the first rule/data cloud
ModelNumber=1;% number of existing data cloud
sum_lamuda=1;
index=1; % the time tag of the first rule/data cloud
A=zeros(1,W+1);% initialise the consequent parameters
C=eye(W+1)*omega;% initialise the covariance matrix
Ye=zeros(L,1);
for i=2:1:L
    datain=data(i,:);%read a new data sample
    [Global_mean,Global_X]=Global_parameter_update(datain,Global_mean,Global_X,i);% update the global mean and average scalar product
    [centerlamuda,centerdensity,localDensity]=Centre_lamuda_calculator(ModelNumber,datain,center,Local_X,Support,Global_mean,Global_X); 
    % 1) calculate the activiation level of the new data sample to each data cloud
    % 2) calculate the global density at the centres of the existing data clouds
    [Ye(i)]=system_output(datain,centerlamuda,A); % generate the system outputs 
    [datadensity]=Global_density_calculator(datain,Global_mean,Global_X); %  calculate the global density at the new data sample
    if datadensity>max(centerdensity)||datadensity<min(centerdensity)
        [OL,target]=overlap_detection(localDensity,densitythreshold); %find the possible overlapping centre
        if OL==1
            [center,Local_X,Support,index,sum_lamuda,~,A,C,~]=Overlap_remove(datain,i,ModelNumber,centerlamuda,sum_lamuda,center,Local_X,Support,index,A,C,W,target,omega);% remove the overlapping rule and replace it with a new one;
        else
            A_inherit=mean(A,1);
            [ModelNumber,center,Support,Local_X,sum_lamuda,index,A,C]=new_cloud_add(datain,ModelNumber,center,Support,Local_X,sum_lamuda,index,A,C,i,W,omega,A_inherit);% add a new rule/data cloud
        end
    else
        [center,Local_X,Support]=local_parameters_update(datain,center,Local_X,Support,ModelNumber); %find the nearest data cloud/rule and update the meta-parameters;
    end
    [centerlamuda,~,~]=Centre_lamuda_calculator(ModelNumber,datain,center,Local_X,Support,Global_mean,Global_X);%calculate the activiation level of the new data sample to each data cloud
    [ModelNumber,center,Local_X,Support,index,sum_lamuda,centerlamuda,A,C]=stale_datacloud_remove(ModelNumber,centerlamuda,sum_lamuda,center,Local_X,Support,index,A,C,i,forgettingfactor);% remove the stale data clouds;
    [A,C]=consequent_parameters_update(datain,dataout(i),ModelNumber,centerlamuda,A,C,W); %update the consequent parameters
end
SystemParam.A=A; % consequent parameters of the identified fuzzy rules
SystemParam.Center=center; % centres of the identified data clouds
SystemParam.N=ModelNumber; % number of the identified data clouds
SystemParam.C=C; % covariance matrixes of the identified fuzzy rules
SystemParam.localX=Local_X; % average scalar products of the identified data clouds
SystemParam.Support=Support; % supports of the identified data clouds
SystemParam.GlobalMean=Global_mean; % global mean
SystemParam.GlobalX=Global_X; % global average scalar product
Estimation=Ye; % output of the ALMMo-1 system
end
function [SystemParam,Estimation]=Classification_learning(data,dataout,omega,densitythreshold)
[L,W]=size(data);
center=data(1,:);% the centre of the first data cloud
Global_mean=data(1,:); % global mean
Global_X=sum(data(1,:).^2);% global average scalar product
Local_X=sum(data(1,:).^2);% the average scalar product of the first data cloud
Support=1;% the support of the first rule/data cloud
ModelNumber=1;% number of existing data cloud
sum_lamuda=1;% the time tag of the first rule/data cloud
index=1;% initialise the consequent parameters
A=zeros(1,W+1);% initialise the consequent parameters
C=eye(W+1)*omega;% initialise the covariance matrix
Ye=zeros(L,1);
for i=2:1:L
    datain=data(i,:);
    [Global_mean,Global_X]=Global_parameter_update(datain,Global_mean,Global_X,i);%read a new data sample
    [centerlamuda,centerdensity,localDensity]=Centre_lamuda_calculator(ModelNumber,datain,center,Local_X,Support,Global_mean,Global_X);% update the global mean and average scalar product
     % 1) calculate the activiation level of the new data sample to each data cloud
    % 2) calculate the global density at the centres of the existing data clouds
    [Ye(i)]=system_output(datain,centerlamuda,A);% generate the system outputs 
    [datadensity]=Global_density_calculator(datain,Global_mean,Global_X);%  calculate the global density at the new data sample
    if datadensity>max(centerdensity)||datadensity<min(centerdensity)
        [OL,target]=overlap_detection(localDensity,densitythreshold); %find the possible overlapping centre
        if OL==1
            [center,Local_X,Support,index,sum_lamuda,~,A,C,~]=Overlap_remove(datain,i,ModelNumber,centerlamuda,sum_lamuda,center,Local_X,Support,index,A,C,W,target,omega);% remove the overlapping rule and replace it with a new one;
        else
            A_inherit=mean(A,1);
            [ModelNumber,center,Support,Local_X,sum_lamuda,index,A,C]=new_cloud_add(datain,ModelNumber,center,Support,Local_X,sum_lamuda,index,A,C,i,W,omega,A_inherit);% add a new rule/data cloud
        end
    else
        [center,Local_X,Support]=local_parameters_update(datain,center,Local_X,Support,ModelNumber); %find the nearest data cloud/rule and update the meta-parameters;
    end
    [centerlamuda,~,~]=Centre_lamuda_calculator(ModelNumber,datain,center,Local_X,Support,Global_mean,Global_X); %calculate the activiation level of the new data sample to each data cloud
    [A,C]=consequent_parameters_update(datain,dataout(i),ModelNumber,centerlamuda,A,C,W); %update the consequent parameters
end
Ye=round(Ye); % binary classification
Ye(find(Ye>1))=1;
Ye(find(Ye<0))=0;
SystemParam.A=A; % consequent parameters of the identified fuzzy rules
SystemParam.Center=center; % centres of the identified data clouds
SystemParam.N=ModelNumber; % number of the identified data clouds
SystemParam.C=C; % covariance matrixes of the identified fuzzy rules
SystemParam.localX=Local_X; % average scalar products of the identified data clouds
SystemParam.Support=Support; % supports of the identified data clouds
SystemParam.GlobalMean=Global_mean; % global mean
SystemParam.GlobalX=Global_X; % global average scalar product
Estimation=Ye; % output of the ALMMo-1 system

end
function [Estimation]=Classification_validation(input,data)
output=input;
A=output.A;
center=output.Center;
ModelNumber=output.N;
Local_X=output.localX;
Support=output.Support;
Global_mean=output.GlobalMean;
Global_X=output.GlobalX;
[L,W]=size(data);
Ye=zeros(L,1);
for i=1:1:L
    [centerlamuda]=weights_calculator(ModelNumber,data(i,:),center,Local_X,Support,Global_mean,Global_X);% calculate the activiation level of the new data sample to each data cloud
    [Ye(i)]=system_output(data(i,:),centerlamuda,A);% generate the system output
end
Ye=round(Ye); % binary classification
Ye(find(Ye>1))=1;
Ye(find(Ye<0))=0;
Estimation=Ye;
end
function [Estimation]=Regression_validation(input,data)
output=input;
A=output.A;
center=output.Center;
ModelNumber=output.N;
Local_X=output.localX;
Support=output.Support;
Global_mean=output.GlobalMean;
Global_X=output.GlobalX;
[L,W]=size(data);
Ye=zeros(L,1);
for i=1:1:L
    [centerlamuda]=weights_calculator(ModelNumber,data(i,:),center,Local_X,Support,Global_mean,Global_X); % calculate the activiation level of the new data sample to each data cloud
    [Ye(i)]=system_output(data(i,:),centerlamuda,A);% generate the system output
end
Estimation=Ye;
end
function [mean_new,X_new]=Global_parameter_update(data,mean,X,n)
mean_new=(n-1)/n*mean+data/n;
X_new=(n-1)/n*X+sum(data.^2)/n;
end
function [centerlamuda,centerdensity,localDensity]=Centre_lamuda_calculator(ModelNumber,datain,center,Local_X,Support,Global_mean,Global_X)
centerdensity=zeros(ModelNumber,1);
for i=1:1:ModelNumber
    centerdensity(i)=1/(sum((center(i,:)-Global_mean).^2)+Global_X-sum(Global_mean.^2));
end
localDensity=zeros(ModelNumber,1);
for i=1:1:ModelNumber
    center(i,:)=center(i,:)*Support(i)/(Support(i)+1)+datain/(Support(i)+1);
    Local_X(i)=Local_X(i)*Support(i)/(Support(i)+1)+sum(datain.^2)/(Support(i)+1);
    AA=(Local_X(i)-sum(center(i,:).^2));
    BB=(sum((datain-center(i,:)).^2));
    if (AA+BB)==0
        localDensity(i)=1;
    else
        localDensity(i)=AA/(AA+BB);
    end
end
if sum(localDensity)~=0
    centerlamuda=localDensity./sum(localDensity);
else
    centerlamuda=ones(ModelNumber,1)./ModelNumber;
end
end
function [Ye]=system_output(datain,lumbda,A)
Ye=[1,datain]*A'*lumbda;
end
function [datadensity]=Global_density_calculator(data,Global_mean,Global_X)
datadensity=1/(sum((data-Global_mean).^2)+Global_X-sum(Global_mean.^2));
end
function [OL,target]=overlap_detection(DA,threshold)
seq=find(DA>threshold);
if isempty(seq)~=1
    OL=1;
    [~,b]=max(DA(seq));
    target=seq(b);
else
    OL=0;
    target=0;
end
end
function [center_new,Local_X_new,support_new,index_new,sum_lamuda_new,centerlamuda_new,A_new,C_new,A_inherit]=Overlap_remove(datain,k,ModelNumber,centerlamuda,sum_lamuda,center,Local_X,support,index,A,C,W,target,omiga)
DD=1:1:ModelNumber;
seq=find(DD~=target);
center_new=center(seq,:);
Local_X_new=Local_X(seq);
index_new=index(seq);
index_new(ModelNumber,1)=k;
sum_lamuda_new=sum_lamuda(seq);
sum_lamuda_new(ModelNumber,1)=0;
centerlamuda_new=centerlamuda(seq)./sum(centerlamuda(seq));
centerlamuda_new(ModelNumber,1)=0;
support_new=support(seq);
A_inherit=A(target,:);
A_new=A(seq,:);
A_new(ModelNumber,:)=A(target,:);
C_new=C(:,:,seq);
C_new(:,:,ModelNumber)=eye(W+1)*omiga;
center_new(ModelNumber,:)=(datain+center(target,:))/2;
Local_X_new(ModelNumber,1)=(sum(datain.^2)+Local_X(target,1))/2;
support_new(ModelNumber,1)=ceil((1+support(target))/2);
end
function [ModelNumber_new,center_new,Support_new,Local_X_new,sum_lamuda_new,index_new,A_new,C_new]=new_cloud_add(data,ModelNumber,center,Support,Local_X,sum_lamuda,index,A,C,i,W,omiga,A_inherit)
ModelNumber_new=ModelNumber+1;
center_new=[center;data];
Support_new=[Support;1];
Local_X_new=[Local_X;sum(data.^2)];
sum_lamuda_new=[sum_lamuda;0];
index_new=[index;i];
A_new=[A;A_inherit];
C_new=zeros(W+1,W+1,ModelNumber_new);
C_new(:,:,ModelNumber_new)=eye(W+1)*omiga;
C_new(:,:,1:1:ModelNumber)=C;
end
function [ModelNumber_new,center_new,Local_X_new,support_new,index_new,sum_lamuda_new,centerlamuda_new,A_new,C_new]=stale_datacloud_remove(ModelNumber,centerlamuda,sum_lamuda,center,Local_X,support,index,A,C,k,forgettingfactor)
sum_lamuda_0=sum_lamuda+centerlamuda;
utility=zeros(ModelNumber,1);
for i=1:1:ModelNumber
    if index(i)~=k
        utility(i)=sum_lamuda_0(i)/(k-index(i));
    else
        utility(i)=1;
    end
end
seq=find(utility>=forgettingfactor);
ModelNumber_new=length(seq);
if ModelNumber_new<ModelNumber
    center_new=center(seq,:);
    Local_X_new=Local_X(seq);
    index_new=index(seq);
    sum_lamuda_new=sum_lamuda_0(seq);
    centerlamuda_new=centerlamuda(seq)./sum(centerlamuda(seq));
    support_new=support(seq);
    A_new=A(seq,:);
    C_new=C(:,:,seq);
else
    center_new=center;
    Local_X_new=Local_X;
    index_new=index;
    support_new=support;
    sum_lamuda_new=sum_lamuda_0;
    centerlamuda_new=centerlamuda;
    A_new=A;
    C_new=C;
end
end
function [center_new,Local_X_new,Support_new]=local_parameters_update(data,center,Local_X,Support,ModelNumber)
localD=sum((repmat(data,ModelNumber,1)-center).^2,2);
[~,label]=min(localD);
center_new=center;
Local_X_new=Local_X;
Support_new=Support;
Support_new(label)=Support(label)+1;
center_new(label,:)=Support(label)/Support_new(label)*center(label,:)+1/Support_new(label)*data;
Local_X_new(label)=Support(label)/Support_new(label)*Local_X(label)+1/Support_new(label)*sum(data.^2);
end
function [A_new,C_new]=consequent_parameters_update(data,y,ModelNumber,centerlamuda,A,C,W)
A_new=zeros(ModelNumber,W+1);
C_new=zeros(W+1,W+1,ModelNumber);
X=[1,data];
for i=1:1:ModelNumber
    C_new(:,:,i)=C(:,:,i)-centerlamuda(i)*C(:,:,i)*X'*X*C(:,:,i)/(1+centerlamuda(i)*X*C(:,:,i)*X');
    A1=A(i,:)'+centerlamuda(i)*C_new(:,:,i)*X'*(y-X*A(i,:)');
    A_new(i,:)=A1';
end
end
function [centerlamuda]=weights_calculator(ModelNumber,datain,center,Local_X,Support,Global_mean,Global_X)
centerdensity=zeros(ModelNumber,1);
for i=1:1:ModelNumber
    centerdensity(i)=1/(sum((center(i,:)-Global_mean).^2)+Global_X-sum(Global_mean.^2));
end
DA=zeros(ModelNumber,1);
W=length(center(1,:));
N=sum(Support);
for i=1:1:ModelNumber
    center(i,:)=center(i,:)*Support(i)/(Support(i)+1)+datain/(Support(i)+1);
    Local_X(i)=Local_X(i)*Support(i)/(Support(i)+1)+sum(datain.^2)/(Support(i)+1);
    AA=(Local_X(i)-sum(center(i,:).^2));
    BB=(sum((datain-center(i,:)).^2));
    if (AA+BB)==0
    DA(i)=1;
    else
    DA(i)=Support(i)/N*gamma((W+1)/2)/(pi^((W+1)/2)*BB^(W/2)*(1+AA/BB).^((W+1)/2));   
    end
end
if sum(DA)~=0
centerlamuda=DA./sum(DA);
else
 centerlamuda=ones(ModelNumber,1)./ModelNumber;
end
end
